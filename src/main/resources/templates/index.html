<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Reactive System Demo</title>
  <style>
    .btn-area {
      display: flex;
      gap: 1rem;
    }
  </style>
</head>
<body>

<h1>Reactive System Demo</h1>

<div id="app">
  <div id="log">
    <div v-for="(m, i) in messages" :key="i" class="msg">{{ m }}</div>
  </div>

  <div class="btn-area">
    <button
      :class="{ loading }"
      :disabled="loading"
      @click="callStream('/demo/stream')"
    >
      {{ loading ? '受信中…' : '/demo/stream を呼ぶ' }}
    </button>
  
    <button
      :class="{ loading }"
      :disabled="loading"
      @click="callStream('/demo/stream/json')"
    >
      {{ loading ? '受信中…' : '/demo/stream/json を呼ぶ' }}
    </button>
  
    <button
      :class="{ loading }"
      :disabled="loading"
      @click="callStream('/demo/delay')"
    >
      {{ loading ? '受信中…' : '/demo/delay を呼ぶ' }}
    </button>
  </div>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<script>
const { createApp, ref } = Vue;

createApp({
  setup() {
    const messages = ref([]);
    const loading  = ref(false);

    // --- SSE フレームを手動でパースするユーティリティ ------------------
    function* parseSSE(chunkText, buffer) {
      buffer.push(chunkText);
      const joined = buffer.join('');
      const events = joined.split(/\r?\n\r?\n/);
      buffer.length = 0;

      const last = events.pop();
      if (last !== undefined) buffer.push(last);

      for (const ev of events) {
        for (const line of ev.split(/\r?\n/)) {
          const m = line.match(/^data:\s?(.*)$/);
          if (m) yield m[1];
        }
      }
    }
    // ---------------------------------------------------------------

    async function callStream(path) {
      // messages.value.length = 0; // クリア
      loading.value = true;
      let responseText = '';
      messages.value.push(responseText);
      const index = messages.value.length - 1;

      try {
        const response = await fetch(path, {
          headers: { 'Accept': 'text/event-stream' }
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const reader      = response.body.getReader();
        const decoder     = new TextDecoder('utf-8');
        const leftoverBuf = [];

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunkText = decoder.decode(value, { stream: true });

          for (const msg of parseSSE(chunkText, leftoverBuf)) {
            messages.value[index] += msg;
            // 自動スクロール
            requestAnimationFrame(() => {
              const logBox = document.getElementById('log');
              logBox.scrollTop = logBox.scrollHeight;
            });
          }
        }
      } catch (err) {
        messages.value.push(`エラー: ${err.message || err}`);
      } finally {
        loading.value = false;
      }
    }

    return { messages, loading, callStream };
  }
}).mount('#app');
</script>

</body>
</html>
