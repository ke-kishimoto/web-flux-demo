<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>Reactive System Demo</title>
</head>

<body>
  <div id="app">
    <h1>SSE Demo</h1>
    <div class="btn-area">
      <button @click="callStream">
        click
      </button>

      <button @click="getCustomers">
        customers
      </button>
    </div>
    <div id="log">
      <div>{{ message }}</div>
      <div>
        <p>件数：{{ customers.length }}</p>
        <table>
          <thead>
            <tr>
              <th>id</th>
              <th>name</th>
              <th>json</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="customer in customers" :key="customer.id">
              <td>{{ customer.id }}</td>
              <td>{{ customer.name }}</td>
              <td>{{ customer }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script>
    const { createApp, ref } = Vue;
    createApp({
      setup() {
        const message = ref('');
        const customers = ref([]);

        function* parseSSE(chunkText, buffer) {
          buffer.push(chunkText);
          const joined = buffer.join('');
          const events = joined.split(/\r?\n\r?\n/);
          buffer.length = 0;

          const last = events.pop();
          if (last !== undefined) buffer.push(last);

          for (const ev of events) {
            for (const line of ev.split(/\r?\n/)) {
              if (line.startsWith("data:")) {
                yield line.slice(5);
              }
            }
          }
        }

        function parseJSON(text) {
          // 空文字列や空白のみの場合はnullを返す
          if (!text || text.trim() === '') {
            return null;
          }
          
          // data:プレフィックスを削除
          if(text.startsWith('data:')) {
            text = text.slice(5); // "data:"を削除
          }
          
          // 再度トリムして空の場合はnullを返す
          text = text.trim();
          if (text === '') {
            return null;
          }
          
          try {
            const json = JSON.parse(text);
            return json;
          } catch (e) {
            console.error('JSON parse error:', e, 'Text:', text);
            return null; // エラー時はnullを返す
          }
        }

        async function getCustomers() {
          const response = await fetch('/customers', {
            headers: { 'Accept': 'text/event-stream' }
          });
          if (!response.ok) throw new Error('Network response was not ok');

          console.log('Response status:', response.status);

          const reader = response.body.getReader();
          const decoder = new TextDecoder('utf-8');
          let buffer = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const parts = buffer.split('\n');
            buffer = parts.pop(); // 残りをバッファへ

            for (const part of parts) {
              console.log('Received part:', part);
              const parsedData = parseJSON(part);
              if (parsedData !== null) {
                customers.value.push(parsedData);
              }
            }
          }
        }

        async function callStream() {
          message.value = '';

          try {
            const response = await fetch('/demo/sse', {
              headers: { 'Accept': 'text/event-stream' }
            });

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            const leftoverBuf = [];

            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              const chunkText = decoder.decode(value, { stream: true });

              for (const msg of parseSSE(chunkText, leftoverBuf)) {
                message.value += msg;
              }
            }
          } catch (err) {
            message.value = `エラー: ${err.message || err}`;
          }
        }

        return {
          message,
          customers,
          callStream,
          getCustomers
        };
      }
    }).mount('#app');
  </script>
</body>

</html>