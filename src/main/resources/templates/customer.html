<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customer Demo</title>
</head>
<body>
  <div id="app">
    <h1>SSE Demo - Reactive vs Blocking Comparison</h1>
    <div class="btn-area">
      <button @click="getCustomersReactiveBulk" :disabled="loading">
        Reactive SSE (No Delay)
      </button>
      <button @click="getCustomersBlockingBulk" :disabled="loading">
        Blocking Bulk JSON
      </button>
      <button @click="clearCustomers">
        Clear
      </button>
      <button @click="cancelProcessing" :disabled="!loading" style="background-color: #ff6b6b; color: white;">
        キャンセル
      </button>
    </div>
    <div id="log">
      <div>
        <p>処理方式：{{ processingType }}</p>
        <p>件数：{{ customers.length }}</p>
        <p>処理時間：{{ processingTime }}ms</p>
        <p v-if="loading">読み込み中...</p>
        <table>
          <thead>
            <tr>
              <th>id</th>
              <th>name</th>
              <th>json</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="customer in customers" :key="customer.id">
              <td>{{ customer.id }}</td>
              <td>{{ customer.name }}</td>
              <td>{{ customer }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

  </div>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script>
const { createApp, ref } = Vue;
    createApp({
      setup() {
        const customers = ref([]);
        const loading = ref(false);
        const processingType = ref('');
        const processingTime = ref(0);
        let startTime = 0;
        let currentController = null; // AbortController用

        function* parseJSON(text) {
          // 空文字列や空白のみの場合は何も yield しない
          if (!text || text.trim() === '') {
            return;
          }
          
          // data:プレフィックスを削除
          if(text.startsWith('data:')) {
            text = text.slice(5); // "data:"を削除
          }
          
          // 再度トリムして空の場合は何も yield しない
          text = text.trim();
          if (text === '') {
            return;
          }
          
          try {
            const json = JSON.parse(text);
            yield json; // 成功した場合のみ yield
          } catch (e) {
            console.error('JSON parse error:', e, 'Text:', text);
            // エラー時は何も yield しない（スキップ）
          }
        }

        async function getCustomersReactiveBulk() {
          await processCustomers('/customers/reactive/bulk', 'Reactive SSE (No Delay)');
        }

        async function getCustomersBlockingBulk() {
          await processCustomersBulk('/customers/blocking/bulk', 'Blocking Bulk JSON');
        }

        async function processCustomersBulk(endpoint, type) {
          if (loading.value) return;
          
          // 前回の処理をキャンセル
          if (currentController) {
            currentController.abort();
          }
          
          currentController = new AbortController();
          loading.value = true;
          customers.value = [];
          processingType.value = type;
          startTime = Date.now();
          processingTime.value = 0;

          try {
            const response = await fetch(endpoint, {
              headers: { 'Accept': 'application/json' },
              signal: currentController.signal // キャンセル用シグナル
            });
            if (!response.ok) throw new Error('Network response was not ok');

            console.log('Response status:', response.status);
            const data = await response.json();
            
            // 一括でデータを設定
            customers.value = data;
            processingTime.value = Date.now() - startTime;
          } catch (error) {
            if (error.name === 'AbortError') {
              console.log('処理がキャンセルされました');
              processingType.value = `${type} - キャンセルされました`;
            } else {
              console.error('Error:', error);
              processingType.value = `Error: ${error.message}`;
            }
          } finally {
            loading.value = false;
            currentController = null;
          }
        }

        async function processCustomers(endpoint, type) {
          if (loading.value) return;
          
          // 前回の処理をキャンセル
          if (currentController) {
            currentController.abort();
          }
          
          currentController = new AbortController();
          loading.value = true;
          customers.value = [];
          processingType.value = type;
          startTime = Date.now();
          processingTime.value = 0;

          try {
            const response = await fetch(endpoint, {
              headers: { 'Accept': 'text/event-stream' },
              signal: currentController.signal // キャンセル用シグナル
            });
            if (!response.ok) throw new Error('Network response was not ok');

            console.log('Response status:', response.status);

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';

            while (true) {
              // キャンセルされていないかチェック
              if (currentController.signal.aborted) {
                reader.cancel();
                break;
              }

              const { done, value } = await reader.read();
              if (done) break;

              buffer += decoder.decode(value, { stream: true });
              const parts = buffer.split('\n');
              buffer = parts.pop(); // 残りをバッファへ

              for (const part of parts) {
                console.log('Received part:', part);
                // ジェネレータ関数から値を取得
                for (const parsedData of parseJSON(part)) {
                  customers.value.push(parsedData);
                }
              }
            }
            processingTime.value = Date.now() - startTime;
          } catch (error) {
            if (error.name === 'AbortError') {
              console.log('処理がキャンセルされました');
              processingType.value = `${type} - キャンセルされました`;
            } else {
              console.error('Error:', error);
              processingType.value = `Error: ${error.message}`;
            }
          } finally {
            loading.value = false;
            currentController = null;
          }
        }

        function clearCustomers() {
          customers.value = [];
          processingType.value = '';
          processingTime.value = 0;
        }

        // キャンセル関数を追加
        function cancelProcessing() {
          if (currentController) {
            currentController.abort();
          }
        }

        return {
          customers,
          loading,
          processingType,
          processingTime,
          getCustomersReactiveBulk,
          getCustomersBlockingBulk,
          clearCustomers,
          cancelProcessing // 新しく追加
        };
      }
    }).mount('#app');
  </script>
  
</body>
</html>