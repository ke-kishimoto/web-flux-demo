<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customer Demo</title>
</head>
<body>
  <div id="app">
    <h1>SSE Demo - Reactive vs Blocking Comparison</h1>
    <div class="btn-area">
      <button @click="getCustomersReactiveBulk" :disabled="loading">
        Reactive SSE (No Delay)
      </button>
      <button @click="getCustomersBlockingBulk" :disabled="loading">
        Blocking Bulk JSON
      </button>
      <button @click="clearCustomers">
        Clear
      </button>
      <button @click="cancelProcessing" :disabled="!loading" style="background-color: #ff6b6b; color: white;">
        キャンセル
      </button>
    </div>
    
    <div class="control-panel" style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f0f8ff;">
      <h3 style="margin-top: 0;">パフォーマンス設定</h3>
      <label style="margin-right: 20px;">
        <input type="checkbox" v-model="virtualScrollConfig.enabled"> 
        仮想スクロールを有効にする
      </label>
      <label style="margin-right: 20px;">
        表示領域の高さ: 
        <input type="number" v-model.number="virtualScrollConfig.containerHeight" min="200" max="800" style="width: 80px;">px
      </label>
      <label style="margin-right: 20px;">
        最大表示件数: 
        <input type="number" v-model.number="displayConfig.maxItems" min="100" max="20000" step="100" style="width: 80px;">
      </label>
      <small style="display: block; margin-top: 5px; color: #666;">
        ※ 仮想スクロール有効時は、画面に見える部分のみレンダリングされます
      </small>
    </div>
    
    <div class="control-panel" style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
      <h3 style="margin-top: 0;">表示制御設定</h3>
      <label style="margin-right: 20px;">
        <input type="checkbox" v-model="displayConfig.enabled"> 
        バッファリング表示を有効にする
      </label>
      <label style="margin-right: 20px;">
        一度に表示する件数: 
        <input type="number" v-model.number="displayConfig.batchSize" min="1" max="100" style="width: 60px;">
      </label>
      <label style="margin-right: 20px;">
        表示間隔(ms): 
        <input type="number" v-model.number="displayConfig.intervalMs" min="50" max="2000" step="50" style="width: 80px;">
      </label>
      <label style="margin-right: 20px;">
        最大受信件数: 
        <input type="number" v-model.number="displayConfig.maxItems" min="100" max="20000" step="100" style="width: 80px;">
      </label>
      <small style="display: block; margin-top: 5px; color: #666;">
        ※ バッファリング無効時は、データを受信次第即座に表示されます<br>
        ※ 最大受信件数に達すると自動的にデータ受信を停止します
      </small>
    </div>
    
    <div id="log">
      <div>
        <p>処理方式：{{ processingType }}</p>
        <p>件数：{{ customers.length }}</p>
        <p v-if="virtualScrollConfig.enabled">表示中：{{ visibleRange.start }}〜{{ visibleRange.end }}行目</p>
        <p>処理時間：{{ processingTime }}ms</p>
        <p v-if="loading">読み込み中...</p>
        
        <!-- 仮想スクロール対応テーブル -->
        <div v-if="virtualScrollConfig.enabled" 
             :style="{ height: virtualScrollConfig.containerHeight + 'px', overflow: 'auto', border: '1px solid #ddd' }"
             @scroll="handleScroll">
          <div :style="{ height: (customers.length * virtualScrollConfig.itemHeight) + 'px', position: 'relative' }">
            <table style="position: absolute; top: 0; width: 100%; border-collapse: collapse;">
              <thead style="position: sticky; top: 0; background: white; z-index: 1;">
                <tr>
                  <th style="border: 1px solid #ddd; padding: 8px;">id</th>
                  <th style="border: 1px solid #ddd; padding: 8px;">name</th>
                  <th style="border: 1px solid #ddd; padding: 8px;">追加時刻</th>
                </tr>
              </thead>
            </table>
            <div :style="{ transform: `translateY(${visibleRange.start * virtualScrollConfig.itemHeight + 40}px)` }">
              <table style="width: 100%; border-collapse: collapse;">
                <tbody>
                  <tr v-for="customer in visibleCustomers" 
                      :key="customer.id"
                      :style="{ height: virtualScrollConfig.itemHeight + 'px' }">
                    <td style="border: 1px solid #ddd; padding: 8px;">{{ customer.id }}</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">{{ customer.name }}</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">{{ customer.addedAt }}</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        
        <!-- 通常表示（仮想スクロール無効時） -->
        <table v-else style="border-collapse: collapse; width: 100%;">
          <thead>
            <tr>
              <th style="border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;">id</th>
              <th style="border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;">name</th>
              <th style="border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;">追加時刻</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="customer in customers" :key="customer.id">
              <td style="border: 1px solid #ddd; padding: 8px;">{{ customer.id }}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">{{ customer.name }}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">{{ customer.addedAt }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

  </div>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script>
const { createApp, ref, computed } = Vue;
    createApp({
      setup() {
        const customers = ref([]);
        const loading = ref(false);
        const processingType = ref('');
        const processingTime = ref(0);
        let startTime = 0;
        let currentController = null; // AbortController用
        
        // 仮想スクロール用の設定
        const virtualScrollConfig = ref({
          enabled: true,
          itemHeight: 40,       // 1行の高さ（px）
          containerHeight: 400, // テーブル表示領域の高さ（px）
          bufferSize: 10        // 画面外でも保持する行数
        });
        
        const scrollTop = ref(0);
        
        // 表示制御設定
        const displayConfig = ref({
          enabled: true,        // バッファリングを有効にするか
          batchSize: 10,        // 一度に表示する件数
          intervalMs: 100,      // 表示間隔（ミリ秒）
          maxItems: 5000        // 最大受信件数
        });

        // 表示する行の範囲を計算
        const visibleRange = computed(() => {
          if (!virtualScrollConfig.value.enabled) {
            return { start: 0, end: customers.value.length };
          }
          
          const itemHeight = virtualScrollConfig.value.itemHeight;
          const containerHeight = virtualScrollConfig.value.containerHeight;
          const bufferSize = virtualScrollConfig.value.bufferSize;
          
          const start = Math.max(0, Math.floor(scrollTop.value / itemHeight) - bufferSize);
          const visibleCount = Math.ceil(containerHeight / itemHeight);
          const end = Math.min(customers.value.length, start + visibleCount + bufferSize * 2);
          
          return { start, end };
        });
        
        // 実際に表示する行
        const visibleCustomers = computed(() => {
          const { start, end } = visibleRange.value;
          return customers.value.slice(start, end).map((customer, index) => ({
            ...customer,
            originalIndex: start + index
          }));
        });
        
        // スクロールイベントハンドラ
        function handleScroll(event) {
          scrollTop.value = event.target.scrollTop;
        }

        function* parseJSON(text) {
          // 空文字列や空白のみの場合は何も yield しない
          if (!text || text.trim() === '') {
            return;
          }
          
          // data:プレフィックスを削除
          if(text.startsWith('data:')) {
            text = text.slice(5); // "data:"を削除
          }
          
          // 再度トリムして空の場合は何も yield しない
          text = text.trim();
          if (text === '') {
            return;
          }
          
          try {
            const json = JSON.parse(text);
            yield json; // 成功した場合のみ yield
          } catch (e) {
            console.error('JSON parse error:', e, 'Text:', text);
            // エラー時は何も yield しない（スキップ）
          }
        }

        async function getCustomersReactiveBulk() {
          await processCustomers('/customers/reactive/bulk', 'Reactive SSE (No Delay)');
        }

        async function getCustomersBlockingBulk() {
          await processCustomersBulk('/customers/blocking/bulk', 'Blocking Bulk JSON');
        }

        async function processCustomersBulk(endpoint, type) {
          if (loading.value) return;
          
          // 前回の処理をキャンセル
          if (currentController) {
            currentController.abort();
          }
          
          currentController = new AbortController();
          loading.value = true;
          customers.value = [];
          processingType.value = type;
          startTime = Date.now();
          processingTime.value = 0;

          try {
            const response = await fetch(endpoint, {
              headers: { 'Accept': 'application/json' },
              signal: currentController.signal // キャンセル用シグナル
            });
            if (!response.ok) throw new Error('Network response was not ok');

            console.log('Response status:', response.status);
            const data = await response.json();
            
            // 一括でデータを設定
            customers.value = data;
            processingTime.value = Date.now() - startTime;
          } catch (error) {
            if (error.name === 'AbortError') {
              console.log('処理がキャンセルされました');
              processingType.value = `${type} - キャンセルされました`;
            } else {
              console.error('Error:', error);
              processingType.value = `Error: ${error.message}`;
            }
          } finally {
            loading.value = false;
            currentController = null;
          }
        }

        async function processCustomers(endpoint, type) {
          if (loading.value) return;
          
          // 前回の処理をキャンセル
          if (currentController) {
            currentController.abort();
          }
          
          currentController = new AbortController();
          loading.value = true;
          customers.value = [];
          processingType.value = type;
          startTime = Date.now();
          processingTime.value = 0;

          // バッファリング用の変数
          let dataBuffer = [];
          let displayTimer = null;

          // バッファリングが有効な場合、定期的に表示するタイマーを開始
          if (displayConfig.value.enabled) {
            displayTimer = setInterval(() => {
              if (dataBuffer.length > 0) {
                const itemsToShow = dataBuffer.splice(0, displayConfig.value.batchSize);
                customers.value.push(...itemsToShow);
                console.log(`バッファから${itemsToShow.length}件表示（残り${dataBuffer.length}件）`);
              }
            }, displayConfig.value.intervalMs);
          }

          try {
            const response = await fetch(endpoint, {
              headers: { 'Accept': 'text/event-stream' },
              signal: currentController.signal // キャンセル用シグナル
            });
            if (!response.ok) throw new Error('Network response was not ok');

            console.log('Response status:', response.status);

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';

            while (true) {
              // キャンセルされていないかチェック
              if (currentController.signal.aborted) {
                reader.cancel();
                if (displayTimer) clearInterval(displayTimer);
                break;
              }

              const { done, value } = await reader.read();
              if (done) {
                console.log('ストリーム完了。バッファリング表示を継続します。');
                break;
              }

              buffer += decoder.decode(value, { stream: true });
              const parts = buffer.split('\n');
              buffer = parts.pop(); // 残りをバッファへ

              for (const part of parts) {
                console.log('Received part:', part);
                // ジェネレータ関数から値を取得
                for (const parsedData of parseJSON(part)) {
                  // 最大件数チェック
                  if (customers.value.length + dataBuffer.length >= displayConfig.value.maxItems) {
                    console.log(`最大件数(${displayConfig.value.maxItems})に達したため、データ受信を停止します`);
                    reader.cancel();
                    break;
                  }
                  
                  const customerWithTime = {
                    ...parsedData,
                    addedAt: new Date().toLocaleTimeString()
                  };

                  if (displayConfig.value.enabled) {
                    // バッファに追加（画面には即座に表示しない）
                    dataBuffer.push(customerWithTime);
                  } else {
                    // 即座に表示
                    customers.value.push(customerWithTime);
                  }
                }
                
                // 最大件数チェック後にループを抜ける
                if (customers.value.length + dataBuffer.length >= displayConfig.value.maxItems) {
                  break;
                }
              }
            }
            
            // ストリーム完了後、バッファに残っているデータを設定間隔で表示
            if (displayConfig.value.enabled && dataBuffer.length > 0) {
              console.log(`ストリーム完了後、残り${dataBuffer.length}件をバッファリング表示します`);
              
              // 既存のタイマーを一旦停止
              if (displayTimer) {
                clearInterval(displayTimer);
              }
              
              // 残りデータ用の新しいタイマーを開始
              displayTimer = setInterval(() => {
                if (dataBuffer.length > 0) {
                  const itemsToShow = dataBuffer.splice(0, displayConfig.value.batchSize);
                  customers.value.push(...itemsToShow);
                  console.log(`残りバッファから${itemsToShow.length}件表示（残り${dataBuffer.length}件）`);
                } else {
                  // バッファが空になったらタイマーを停止
                  clearInterval(displayTimer);
                  displayTimer = null;
                  console.log('全てのデータ表示が完了しました');
                }
              }, displayConfig.value.intervalMs);
            }
            
            processingTime.value = Date.now() - startTime;
          } catch (error) {
            if (displayTimer) clearInterval(displayTimer);
            if (error.name === 'AbortError') {
              console.log('処理がキャンセルされました');
              processingType.value = `${type} - キャンセルされました`;
            } else {
              console.error('Error:', error);
              processingType.value = `Error: ${error.message}`;
            }
          } finally {
            loading.value = false;
            currentController = null;
            // 注意: displayTimerは残りデータの表示が完了するまで継続される場合がある
          }
        }

        function clearCustomers() {
          customers.value = [];
          processingType.value = '';
          processingTime.value = 0;
        }

        // キャンセル関数を追加
        function cancelProcessing() {
          if (currentController) {
            currentController.abort();
          }
        }

        return {
          customers,
          loading,
          processingType,
          processingTime,
          displayConfig,
          virtualScrollConfig,
          visibleCustomers,
          visibleRange,
          handleScroll,
          getCustomersReactiveBulk,
          getCustomersBlockingBulk,
          clearCustomers,
          cancelProcessing // 新しく追加
        };
      }
    }).mount('#app');
  </script>
  
</body>
</html>